// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for APIConfigurationKind.
const (
	Httprest APIConfigurationKind = "http/rest"
)

// Defines values for APIConfigurationVersion.
const (
	ApiPlatformWso2Comv1 APIConfigurationVersion = "api-platform.wso2.com/v1"
)

// Defines values for APIDetailResponseApiMetadataStatus.
const (
	APIDetailResponseApiMetadataStatusDeployed APIDetailResponseApiMetadataStatus = "deployed"
	APIDetailResponseApiMetadataStatusFailed   APIDetailResponseApiMetadataStatus = "failed"
	APIDetailResponseApiMetadataStatusPending  APIDetailResponseApiMetadataStatus = "pending"
)

// Defines values for APIListItemStatus.
const (
	APIListItemStatusDeployed APIListItemStatus = "deployed"
	APIListItemStatusFailed   APIListItemStatus = "failed"
	APIListItemStatusPending  APIListItemStatus = "pending"
)

// Defines values for OperationMethod.
const (
	DELETE  OperationMethod = "DELETE"
	GET     OperationMethod = "GET"
	HEAD    OperationMethod = "HEAD"
	OPTIONS OperationMethod = "OPTIONS"
	PATCH   OperationMethod = "PATCH"
	POST    OperationMethod = "POST"
	PUT     OperationMethod = "PUT"
)

// APIConfigData defines model for APIConfigData.
type APIConfigData struct {
	// Context Base path for all API routes (must start with /, no trailing slash)
	Context string `json:"context"`

	// Name Human-readable API name
	Name string `json:"name"`

	// Operations List of HTTP operations/routes
	Operations []Operation `json:"operations"`

	// Upstream List of backend service URLs
	Upstream []Upstream `json:"upstream"`

	// Version Semantic version of the API
	Version string `json:"version"`
}

// APIConfiguration defines model for APIConfiguration.
type APIConfiguration struct {
	Data APIConfigData `json:"data"`

	// Kind API type
	Kind APIConfigurationKind `json:"kind"`

	// Version API specification version
	Version APIConfigurationVersion `json:"version"`
}

// APIConfigurationKind API type
type APIConfigurationKind string

// APIConfigurationVersion API specification version
type APIConfigurationVersion string

// APICreateResponse defines model for APICreateResponse.
type APICreateResponse struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Id Unique identifier for the created API configuration
	Id      *openapi_types.UUID `json:"id,omitempty"`
	Message *string             `json:"message,omitempty"`
	Status  *string             `json:"status,omitempty"`
}

// APIDetailResponse defines model for APIDetailResponse.
type APIDetailResponse struct {
	Api *struct {
		Configuration *APIConfiguration   `json:"configuration,omitempty"`
		Id            *openapi_types.UUID `json:"id,omitempty"`
		Metadata      *struct {
			CreatedAt  *time.Time                          `json:"created_at,omitempty"`
			DeployedAt *time.Time                          `json:"deployed_at,omitempty"`
			Status     *APIDetailResponseApiMetadataStatus `json:"status,omitempty"`
			UpdatedAt  *time.Time                          `json:"updated_at,omitempty"`
		} `json:"metadata,omitempty"`
	} `json:"api,omitempty"`
	Status *string `json:"status,omitempty"`
}

// APIDetailResponseApiMetadataStatus defines model for APIDetailResponse.Api.Metadata.Status.
type APIDetailResponseApiMetadataStatus string

// APIListItem defines model for APIListItem.
type APIListItem struct {
	Context   *string             `json:"context,omitempty"`
	CreatedAt *time.Time          `json:"created_at,omitempty"`
	Id        *openapi_types.UUID `json:"id,omitempty"`
	Name      *string             `json:"name,omitempty"`
	Status    *APIListItemStatus  `json:"status,omitempty"`
	UpdatedAt *time.Time          `json:"updated_at,omitempty"`
	Version   *string             `json:"version,omitempty"`
}

// APIListItemStatus defines model for APIListItem.Status.
type APIListItemStatus string

// APIUpdateResponse defines model for APIUpdateResponse.
type APIUpdateResponse struct {
	Id        *openapi_types.UUID `json:"id,omitempty"`
	Message   *string             `json:"message,omitempty"`
	Status    *string             `json:"status,omitempty"`
	UpdatedAt *time.Time          `json:"updated_at,omitempty"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Errors Detailed validation errors
	Errors *[]ValidationError `json:"errors,omitempty"`

	// Message High-level error description
	Message string `json:"message"`
	Status  string `json:"status"`
}

// Operation defines model for Operation.
type Operation struct {
	// Method HTTP method
	Method OperationMethod `json:"method"`

	// Path Route path with optional {param} placeholders
	Path string `json:"path"`
}

// OperationMethod HTTP method
type OperationMethod string

// Upstream defines model for Upstream.
type Upstream struct {
	// Url Backend service URL (may include path prefix like /api/v2)
	Url string `json:"url"`
}

// ValidationError defines model for ValidationError.
type ValidationError struct {
	// Field Field that failed validation
	Field *string `json:"field,omitempty"`

	// Message Human-readable error message
	Message *string `json:"message,omitempty"`
}

// CreateAPIJSONRequestBody defines body for CreateAPI for application/json ContentType.
type CreateAPIJSONRequestBody = APIConfiguration

// UpdateAPIJSONRequestBody defines body for UpdateAPI for application/json ContentType.
type UpdateAPIJSONRequestBody = APIConfiguration

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all API configurations
	// (GET /apis)
	ListAPIs(c *gin.Context)
	// Create a new API configuration
	// (POST /apis)
	CreateAPI(c *gin.Context)
	// Delete an API configuration
	// (DELETE /apis/{id})
	DeleteAPI(c *gin.Context, id string)
	// Get API configuration by ID
	// (GET /apis/{id})
	GetAPIByID(c *gin.Context, id string)
	// Update an existing API configuration
	// (PUT /apis/{id})
	UpdateAPI(c *gin.Context, id string)
	// Health check endpoint
	// (GET /health)
	HealthCheck(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// ListAPIs operation middleware
func (siw *ServerInterfaceWrapper) ListAPIs(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListAPIs(c)
}

// CreateAPI operation middleware
func (siw *ServerInterfaceWrapper) CreateAPI(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateAPI(c)
}

// DeleteAPI operation middleware
func (siw *ServerInterfaceWrapper) DeleteAPI(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteAPI(c, id)
}

// GetAPIByID operation middleware
func (siw *ServerInterfaceWrapper) GetAPIByID(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetAPIByID(c, id)
}

// UpdateAPI operation middleware
func (siw *ServerInterfaceWrapper) UpdateAPI(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateAPI(c, id)
}

// HealthCheck operation middleware
func (siw *ServerInterfaceWrapper) HealthCheck(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.HealthCheck(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/apis", wrapper.ListAPIs)
	router.POST(options.BaseURL+"/apis", wrapper.CreateAPI)
	router.DELETE(options.BaseURL+"/apis/:id", wrapper.DeleteAPI)
	router.GET(options.BaseURL+"/apis/:id", wrapper.GetAPIByID)
	router.PUT(options.BaseURL+"/apis/:id", wrapper.UpdateAPI)
	router.GET(options.BaseURL+"/health", wrapper.HealthCheck)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/3VPMV1QLwAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
