# Data Model: Gateway with Controller and Router

**Date**: 2025-10-11
**Phase**: 1 - Design & Contracts
**Purpose**: Define data structures for API configurations, storage, and xDS translation

## Overview

This document defines the data model for the Gateway system. The model includes:
1. **User-Facing Entities**: API Configuration format (YAML/JSON input)
2. **Internal Entities**: Storage representations and xDS snapshots
3. **Validation Rules**: Constraints and requirements for each entity
4. **State Transitions**: Configuration lifecycle states

---

## Entity 1: API Configuration

### Description
The API Configuration represents a complete REST API definition provided by users in YAML or JSON format. It defines how the gateway should route HTTP requests to backend services.

**Code Generation Note**: The Go data structures for this entity are generated from the OpenAPI specification (`gateway-controller/api/openapi.yaml`) using oapi-codegen. The generated types are located in `pkg/api/generated.go` and include full JSON/YAML struct tags, validation tags, and OpenAPI documentation.

### Format Specification

```yaml
version: api-platform.wso2.com/v1
kind: http/rest
data:
  name: string              # Human-readable API name
  version: string           # Semantic version (e.g., v1.0, v2.1)
  context: string           # Base path for all routes (e.g., /weather)
  upstream:
    - url: string           # Backend service URL (may include path prefix)
  operations:
    - method: string        # HTTP method (GET, POST, PUT, DELETE, PATCH, etc.)
      path: string          # Route path with optional {params}
```

### Example

```yaml
version: api-platform.wso2.com/v1
kind: http/rest
data:
  name: Weather API
  version: v1.0
  context: /weather
  upstream:
    - url: https://api.weather.com/api/v2
  operations:
    - method: GET
      path: /{country_code}/{city}
    - method: POST
      path: /{country_code}/{city}
    - method: PUT
      path: /{country_code}/{city}
```

### Go Data Structure

**GENERATED CODE** (from `pkg/api/generated.go` via oapi-codegen):

```go
// APIConfiguration represents the complete user-provided API configuration
// Generated from OpenAPI schema components/schemas/APIConfiguration
type APIConfiguration struct {
    Version string           `json:"version" yaml:"version"`
    Kind    string           `json:"kind" yaml:"kind"`
    Data    APIConfigData    `json:"data" yaml:"data"`
}

// APIConfigData contains the API-specific configuration
// Generated from OpenAPI schema components/schemas/APIConfigData
type APIConfigData struct {
    Name       string          `json:"name" yaml:"name"`
    Version    string          `json:"version" yaml:"version"`
    Context    string          `json:"context" yaml:"context"`
    Upstream   []Upstream      `json:"upstream" yaml:"upstream"`
    Operations []Operation     `json:"operations" yaml:"operations"`
}

// Upstream represents a backend service
// Generated from OpenAPI schema components/schemas/Upstream
type Upstream struct {
    URL string `json:"url" yaml:"url"`
}

// Operation represents a single HTTP operation/route
// Generated from OpenAPI schema components/schemas/Operation
type Operation struct {
    Method string `json:"method" yaml:"method"`
    Path   string `json:"path" yaml:"path"`
}
```

**Note**: These types are auto-generated by oapi-codegen from the OpenAPI specification. Do not manually edit `pkg/api/generated.go`. To modify these types, update the OpenAPI spec in `gateway-controller/api/openapi.yaml` and regenerate using `make generate`.

### Validation Rules

| Field | Constraint | Error if Violated |
|-------|-----------|-------------------|
| `version` | Must equal "api-platform.wso2.com/v1" | "Unsupported API version" |
| `kind` | Must equal "http/rest" | "Unsupported API kind (only http/rest supported)" |
| `data.name` | Non-empty string, 1-100 characters | "API name is required and must be 1-100 characters" |
| `data.version` | Non-empty string, matches semantic version pattern (e.g., v1.0) | "API version is required and must follow format vX.Y" |
| `data.context` | Must start with `/`, no trailing slash, 1-200 characters | "Context must start with / and cannot end with /" |
| `data.upstream` | At least one upstream URL | "At least one upstream URL is required" |
| `data.upstream[].url` | Valid HTTP/HTTPS URL | "Invalid upstream URL format" |
| `data.operations` | At least one operation | "At least one operation is required" |
| `data.operations[].method` | One of: GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS | "Invalid HTTP method" |
| `data.operations[].path` | Must start with `/`, valid path with optional `{param}` placeholders | "Invalid operation path format" |

### Additional Constraints

1. **Uniqueness**: The combination of `(name, version)` must be unique across all deployed APIs
2. **Context Consistency**: For the same API `name` but different `version`, the `context` must be identical
3. **Path Parameters**: Placeholders in `path` (e.g., `{city}`) are allowed; validation ensures balanced braces
4. **Upstream Path Handling**: If upstream URL contains a path component (e.g., `/api/v2`), the gateway must preserve it when forwarding requests

---

## Code Generation: REST API Server Interface

### Generated ServerInterface

oapi-codegen generates a Go interface that must be implemented to handle REST API requests. This interface is defined in `pkg/api/generated.go`:

```go
// ServerInterface represents all server handlers.
// Generated by oapi-codegen from the OpenAPI specification.
type ServerInterface interface {
    // HealthCheck returns the health status of the Gateway Controller
    // (GET /health)
    HealthCheck(c *gin.Context)

    // CreateAPI submits a new API configuration
    // (POST /apis)
    CreateAPI(c *gin.Context)

    // ListAPIs retrieves all deployed API configurations
    // (GET /apis)
    ListAPIs(c *gin.Context)

    // GetAPIByNameVersion retrieves a specific API configuration by name and version
    // (GET /apis/{name}/{version})
    GetAPIByNameVersion(c *gin.Context, name string, version string)

    // UpdateAPI updates an existing API configuration
    // (PUT /apis/{name}/{version})
    UpdateAPI(c *gin.Context, name string, version string)

    // DeleteAPI removes an API configuration
    // (DELETE /apis/{name}/{version})
    DeleteAPI(c *gin.Context, name string, version string)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router *gin.Engine, si ServerInterface) {
    // Implementation generated by oapi-codegen
    // Sets up routes and binds them to ServerInterface methods
}
```

### Handler Implementation

The business logic is implemented in `pkg/api/handlers/handlers.go` by creating a type that satisfies the `ServerInterface`:

```go
// APIServer implements the generated ServerInterface
type APIServer struct {
    store     *storage.ConfigStore  // In-memory config store
    db        storage.Database      // bbolt database
    xdsServer *xds.Server           // xDS server for Envoy communication
    logger    *zap.Logger           // Structured logger
}

// NewAPIServer creates a new API server with dependencies
func NewAPIServer(store *storage.ConfigStore, db storage.Database, xdsServer *xds.Server, logger *zap.Logger) *APIServer {
    return &APIServer{
        store:     store,
        db:        db,
        xdsServer: xdsServer,
        logger:    logger,
    }
}

// HealthCheck implements ServerInterface.HealthCheck
func (s *APIServer) HealthCheck(c *gin.Context) {
    c.JSON(http.StatusOK, gin.H{
        "status":    "healthy",
        "timestamp": time.Now().Format(time.RFC3339),
    })
}

// CreateAPI implements ServerInterface.CreateAPI
func (s *APIServer) CreateAPI(c *gin.Context) {
    var req api.APIConfiguration

    // Parse request body (supports both JSON and YAML)
    if err := c.ShouldBind(&req); err != nil {
        c.JSON(http.StatusBadRequest, api.ErrorResponse{
            Status:  "error",
            Message: "Invalid request format",
            Errors:  []api.ValidationError{{Field: "body", Message: err.Error()}},
        })
        return
    }

    // Validate configuration
    if errs := s.validateConfig(&req); len(errs) > 0 {
        c.JSON(http.StatusBadRequest, api.ErrorResponse{
            Status:  "error",
            Message: "Configuration validation failed",
            Errors:  errs,
        })
        return
    }

    // Create stored configuration
    storedCfg := &storage.StoredAPIConfig{
        ID:            generateID(),
        Configuration: req,
        Status:        storage.StatusPending,
        CreatedAt:     time.Now(),
        UpdatedAt:     time.Now(),
    }

    // Atomic dual-write: database + in-memory
    if err := s.db.SaveConfig(storedCfg); err != nil {
        s.logger.Error("Failed to save config to database", zap.Error(err))
        c.JSON(http.StatusInternalServerError, api.ErrorResponse{
            Status:  "error",
            Message: "Failed to persist configuration",
        })
        return
    }

    if err := s.store.Add(storedCfg); err != nil {
        // Rollback database write
        _ = s.db.DeleteConfig(storedCfg.ID)
        c.JSON(http.StatusConflict, api.ErrorResponse{
            Status:  "error",
            Message: err.Error(),
        })
        return
    }

    // Update xDS snapshot asynchronously
    go s.updateXDSSnapshot()

    // Return success response
    c.JSON(http.StatusCreated, api.APICreateResponse{
        Status:    "success",
        Message:   "API configuration created successfully",
        ID:        storedCfg.ID,
        CreatedAt: storedCfg.CreatedAt,
    })
}

// Similar implementations for ListAPIs, GetAPIByID, UpdateAPI, DeleteAPI
```

### Generated Response Types

oapi-codegen also generates response types from the OpenAPI spec:

```go
// APICreateResponse - Generated from OpenAPI schema
type APICreateResponse struct {
    Status    string    `json:"status"`
    Message   string    `json:"message"`
    ID        string    `json:"id"`
    CreatedAt time.Time `json:"created_at"`
}

// APIListItem - Generated from OpenAPI schema
type APIListItem struct {
    ID        string    `json:"id"`
    Name      string    `json:"name"`
    Version   string    `json:"version"`
    Context   string    `json:"context"`
    Status    string    `json:"status"`
    CreatedAt time.Time `json:"created_at"`
    UpdatedAt time.Time `json:"updated_at"`
}

// ErrorResponse - Generated from OpenAPI schema
type ErrorResponse struct {
    Status  string            `json:"status"`
    Message string            `json:"message"`
    Errors  []ValidationError `json:"errors,omitempty"`
}

// ValidationError - Generated from OpenAPI schema
type ValidationError struct {
    Field   string `json:"field"`
    Message string `json:"message"`
}
```

---

## Entity 2: In-Memory Configuration Store

### Description
In-memory maps that serve as the primary runtime data source for fast access and xDS cache generation. These maps are loaded from the database on startup and updated on every configuration change.

### Go Data Structure

```go
// ConfigStore holds all API configurations in memory
type ConfigStore struct {
    mu          sync.RWMutex                    // Protects concurrent access
    configs     map[string]*StoredAPIConfig     // Key: config ID
    nameVersion map[string]string               // Key: "name:version" → Value: config ID (for uniqueness checks)
    snapVersion int64                           // Current xDS snapshot version (monotonically increasing)
}

// NewConfigStore creates a new in-memory config store
func NewConfigStore() *ConfigStore {
    return &ConfigStore{
        configs:     make(map[string]*StoredAPIConfig),
        nameVersion: make(map[string]string),
        snapVersion: 0,
    }
}

// Add stores a new configuration in memory
func (cs *ConfigStore) Add(cfg *StoredAPIConfig) error {
    cs.mu.Lock()
    defer cs.mu.Unlock()

    key := fmt.Sprintf("%s:%s", cfg.Configuration.Data.Name, cfg.Configuration.Data.Version)
    if existingID, exists := cs.nameVersion[key]; exists {
        return fmt.Errorf("configuration with name '%s' and version '%s' already exists (ID: %s)",
            cfg.Configuration.Data.Name, cfg.Configuration.Data.Version, existingID)
    }

    cs.configs[cfg.ID] = cfg
    cs.nameVersion[key] = cfg.ID
    return nil
}

// Update modifies an existing configuration in memory
func (cs *ConfigStore) Update(cfg *StoredAPIConfig) error {
    cs.mu.Lock()
    defer cs.mu.Unlock()

    existing, exists := cs.configs[cfg.ID]
    if !exists {
        return fmt.Errorf("configuration with ID '%s' not found", cfg.ID)
    }

    // If name/version changed, update the nameVersion index
    oldKey := fmt.Sprintf("%s:%s", existing.Configuration.Data.Name, existing.Configuration.Data.Version)
    newKey := fmt.Sprintf("%s:%s", cfg.Configuration.Data.Name, cfg.Configuration.Data.Version)

    if oldKey != newKey {
        delete(cs.nameVersion, oldKey)
        cs.nameVersion[newKey] = cfg.ID
    }

    cs.configs[cfg.ID] = cfg
    return nil
}

// Delete removes a configuration from memory
func (cs *ConfigStore) Delete(id string) error {
    cs.mu.Lock()
    defer cs.mu.Unlock()

    cfg, exists := cs.configs[id]
    if !exists {
        return fmt.Errorf("configuration with ID '%s' not found", id)
    }

    key := fmt.Sprintf("%s:%s", cfg.Configuration.Data.Name, cfg.Configuration.Data.Version)
    delete(cs.nameVersion, key)
    delete(cs.configs, id)
    return nil
}

// Get retrieves a configuration by ID
func (cs *ConfigStore) Get(id string) (*StoredAPIConfig, error) {
    cs.mu.RLock()
    defer cs.mu.RUnlock()

    cfg, exists := cs.configs[id]
    if !exists {
        return nil, fmt.Errorf("configuration with ID '%s' not found", id)
    }
    return cfg, nil
}

// GetAll returns all configurations
func (cs *ConfigStore) GetAll() []*StoredAPIConfig {
    cs.mu.RLock()
    defer cs.mu.RUnlock()

    result := make([]*StoredAPIConfig, 0, len(cs.configs))
    for _, cfg := range cs.configs {
        result = append(result, cfg)
    }
    return result
}

// IncrementSnapshotVersion atomically increments and returns the next snapshot version
func (cs *ConfigStore) IncrementSnapshotVersion() int64 {
    cs.mu.Lock()
    defer cs.mu.Unlock()

    cs.snapVersion++
    return cs.snapVersion
}

// GetSnapshotVersion returns the current snapshot version
func (cs *ConfigStore) GetSnapshotVersion() int64 {
    cs.mu.RLock()
    defer cs.mu.RUnlock()

    return cs.snapVersion
}
```

---

## Entity 3: Stored Configuration

### Description
Internal representation of API Configuration as stored in bbolt database. Includes metadata for lifecycle management. Database serves as the persistence layer and is synchronized with in-memory maps.

### Go Data Structure

```go
// StoredAPIConfig represents the configuration stored in the database and in-memory
type StoredAPIConfig struct {
    ID             string               `json:"id"`              // Unique identifier (generated)
    Configuration  APIConfiguration     `json:"configuration"`   // User-provided config
    Status         ConfigStatus         `json:"status"`          // Current state
    CreatedAt      time.Time            `json:"created_at"`
    UpdatedAt      time.Time            `json:"updated_at"`
    DeployedAt     *time.Time           `json:"deployed_at"`     // Nil if not yet deployed
    DeployedVersion int64               `json:"deployed_version"` // xDS snapshot version
}

// ConfigStatus represents the lifecycle state
type ConfigStatus string

const (
    StatusPending   ConfigStatus = "pending"    // Submitted but not yet deployed
    StatusDeployed  ConfigStatus = "deployed"   // Active in Router
    StatusFailed    ConfigStatus = "failed"     // Deployment failed
)
```

### Storage Schema (bbolt Buckets)

```
gateway-controller.db
├── apis/                        # Bucket: API configurations
│   └── {id} → StoredAPIConfig   # Key: config ID, Value: JSON-encoded config
│
├── audit/                       # Bucket: Audit logs
│   └── {timestamp}_{id} → AuditEvent  # Key: timestamp+ID, Value: event details
│
└── metadata/                    # Bucket: System metadata
    └── last_snapshot_version → int64  # Last xDS snapshot version number
```

### State Transitions

```
[User submits config] → Pending
                         ↓
                  [Validation pass] → Deployed
                         ↓
                  [Validation fail] → Failed

[User updates config] → Deployed (if valid) or Failed (if invalid)
[User deletes config] → [Removed from storage]
```

### Startup Flow: Database to In-Memory Loading

On Gateway-Controller startup, all configurations are loaded from the database into in-memory maps:

```go
// LoadFromDatabase loads all configurations from bbolt into the in-memory store
func (cs *ConfigStore) LoadFromDatabase(db *bolt.DB) error {
    return db.View(func(tx *bolt.Tx) error {
        bucket := tx.Bucket([]byte("apis"))
        if bucket == nil {
            // No configurations stored yet
            return nil
        }

        cursor := bucket.Cursor()
        for k, v := cursor.First(); k != nil; k, v = cursor.Next() {
            var cfg StoredAPIConfig
            if err := json.Unmarshal(v, &cfg); err != nil {
                return fmt.Errorf("failed to unmarshal config %s: %w", k, err)
            }

            // Add to in-memory store (bypassing locks since we're in startup)
            cs.configs[cfg.ID] = &cfg
            key := fmt.Sprintf("%s:%s", cfg.Configuration.Data.Name, cfg.Configuration.Data.Version)
            cs.nameVersion[key] = cfg.ID

            // Track highest deployed version for snapshot versioning
            if cfg.DeployedVersion > cs.snapVersion {
                cs.snapVersion = cfg.DeployedVersion
            }
        }

        log.Info("Loaded %d configurations from database", len(cs.configs))
        return nil
    })
}
```

**Startup Sequence**:
1. Initialize bbolt database connection
2. Create empty `ConfigStore` (in-memory maps)
3. Call `LoadFromDatabase()` to populate in-memory maps
4. Generate initial xDS snapshot from in-memory configurations
5. Start xDS server (ready to serve Envoy)
6. Start REST API server (ready to accept user requests)

---

## Entity 4: Audit Event

### Description
Record of configuration changes for audit trail and debugging.

### Go Data Structure

```go
// AuditEvent represents a configuration change event
type AuditEvent struct {
    ID            string                 `json:"id"`             // Event unique ID
    Timestamp     time.Time              `json:"timestamp"`
    Operation     AuditOperation         `json:"operation"`      // CREATE, UPDATE, DELETE
    ConfigID      string                 `json:"config_id"`      // Affected configuration ID
    ConfigName    string                 `json:"config_name"`    // API name for readability
    ConfigVersion string                 `json:"config_version"` // API version
    Status        string                 `json:"status"`         // SUCCESS, FAILED
    ErrorMessage  string                 `json:"error_message"`  // If status=FAILED
    Details       map[string]interface{} `json:"details"`        // Additional context
}

// AuditOperation represents the type of change
type AuditOperation string

const (
    AuditCreate AuditOperation = "CREATE"
    AuditUpdate AuditOperation = "UPDATE"
    AuditDelete AuditOperation = "DELETE"
    AuditQuery  AuditOperation = "QUERY"  // Optional: log read operations
)
```

### Validation Rules

- `ID`: Auto-generated UUID
- `Timestamp`: Auto-set to current time
- `Operation`: Must be one of the defined constants
- `ConfigID`: Must reference a valid configuration ID
- `Status`: "SUCCESS" or "FAILED"

---

## Entity 5: xDS Snapshot

### Description
Internal representation of Envoy configuration snapshot. This is generated from API Configuration and pushed to Router via xDS protocol.

### Go Data Structure (using go-control-plane types)

```go
import (
    cluster "github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3"
    listener "github.com/envoyproxy/go-control-plane/envoy/config/listener/v3"
    route "github.com/envoyproxy/go-control-plane/envoy/config/route/v3"
    "github.com/envoyproxy/go-control-plane/pkg/cache/v3"
)

// xDSSnapshot is an alias for go-control-plane's snapshot
type xDSSnapshot = cache.Snapshot

// SnapshotResources contains the Envoy resources for a complete configuration
type SnapshotResources struct {
    Version   string                // Snapshot version (incrementing integer as string)
    Listeners []*listener.Listener  // HTTP listeners
    Routes    []*route.RouteConfiguration  // Route configurations
    Clusters  []*cluster.Cluster    // Upstream clusters
    Endpoints []*endpoint.ClusterLoadAssignment  // Optional: endpoint assignments
}
```

### Translation Logic: In-Memory Maps → Envoy Resources (SotW)

The xDS translator reads ALL configurations from the in-memory `ConfigStore` and generates a complete snapshot containing all Envoy resources. This implements the State-of-the-World (SotW) protocol.

#### Translation Process
```go
// GenerateSnapshot creates a complete xDS snapshot from in-memory configurations
func GenerateSnapshot(store *ConfigStore) (*cache.Snapshot, error) {
    // Get all configurations from in-memory store
    allConfigs := store.GetAll()

    var listeners []*listener.Listener
    var routes []*route.RouteConfiguration
    var clusters []*cluster.Cluster

    // Translate each configuration to Envoy resources
    for _, cfg := range allConfigs {
        if cfg.Status != StatusDeployed {
            continue // Skip non-deployed configs
        }

        // Generate listener, route, and cluster for this config
        l := createListener(cfg)
        r := createRouteConfig(cfg)
        c := createCluster(cfg)

        listeners = append(listeners, l)
        routes = append(routes, r)
        clusters = append(clusters, c)
    }

    // Increment snapshot version and create new snapshot
    version := store.IncrementSnapshotVersion()
    snapshot, err := cache.NewSnapshot(
        fmt.Sprintf("%d", version),
        map[resource.Type][]types.Resource{
            resource.ClusterType:  clustersToResources(clusters),
            resource.RouteType:    routesToResources(routes),
            resource.ListenerType: listenersToResources(listeners),
        },
    )

    return snapshot, err
}
```

#### Listener Creation
For each unique context path, create an Envoy Listener:
- **Name**: `listener_http_{port}` (e.g., `listener_http_8080`)
- **Address**: `0.0.0.0:{port}` (default: 8080)
- **Filter Chain**: HTTP Connection Manager with reference to RouteConfiguration

#### Route Configuration Creation
For each API Configuration, create a RouteConfiguration:
- **Name**: `route_{api_name}_{api_version}` (e.g., `route_weather_api_v1_0`)
- **Virtual Host**:
  - **Domains**: `["*"]` (accept all domains)
  - **Routes**: One route per operation mapping `{method, path}` to cluster

#### Cluster Creation
For each unique upstream URL, create a Cluster:
- **Name**: `cluster_{sanitized_upstream_url}` (e.g., `cluster_api_weather_com`)
- **Type**: `STRICT_DNS` or `LOGICAL_DNS`
- **Load Assignment**: Endpoint with upstream host and port

#### Path Rewriting
If upstream URL contains a path prefix (e.g., `https://api.weather.com/api/v2`):
- Extract base URL: `https://api.weather.com`
- Extract path prefix: `/api/v2`
- Configure route to prepend `/api/v2` to all forwarded requests

### Example Translation

**Input (API Configuration)**:
```yaml
data:
  name: Weather API
  version: v1.0
  context: /weather
  upstream:
    - url: https://api.weather.com/api/v2
  operations:
    - method: GET
      path: /{country_code}/{city}
```

**Output (Envoy Resources - Conceptual)**:
- **Listener**: `listener_http_8080` listening on `0.0.0.0:8080`
- **Route**: `route_weather_api_v1_0`
  - Match: `GET /weather/{country_code}/{city}`
  - Action: Forward to `cluster_api_weather_com`
  - Prefix Rewrite: Prepend `/api/v2` → final path: `/api/v2/{country_code}/{city}`
- **Cluster**: `cluster_api_weather_com`
  - Host: `api.weather.com:443`
  - TLS: Enabled (HTTPS upstream)

---

## Data Flow Summary

### Startup Flow
```
1. Gateway-Controller starts
           ↓
2. Initialize bbolt database connection
           ↓
3. Create empty ConfigStore (in-memory maps)
           ↓
4. Load all StoredAPIConfig from database → populate in-memory maps
           ↓
5. Generate initial xDS snapshot from in-memory maps (SotW)
           ↓
6. Start xDS server (Router can now connect)
           ↓
7. Start REST API server (ready for user requests)
```

### Runtime Flow (User Configuration Change)
```
1. User submits API Configuration (YAML/JSON) via REST API
           ↓
2. Gateway-Controller parses → APIConfiguration struct
           ↓
3. Validation checks (rules from Entity 1)
           ↓
4. BEGIN ATOMIC TRANSACTION:
   - Store as StoredAPIConfig in bbolt database
   - Update in-memory ConfigStore maps
   END TRANSACTION
           ↓
5. Log AuditEvent (CREATE/UPDATE/DELETE operation)
           ↓
6. Generate complete xDS snapshot from ALL configs in memory (SotW)
   - Iterate through all in-memory configurations
   - Translate each to Envoy resources (Listener, Route, Cluster)
   - Increment snapshot version
           ↓
7. Update go-control-plane snapshot cache with new snapshot
           ↓
8. Envoy (Router) receives snapshot via xDS stream
           ↓
9. Router applies complete configuration state and routes traffic
```

**Key Points**:
- In-memory maps are the primary data source for xDS generation
- Database serves as persistence layer for durability and startup recovery
- Every configuration change triggers a complete snapshot generation (SotW approach)
- Updates to in-memory maps and database are atomic (both succeed or both fail)

---

## Validation & Error Handling

### Validation Stages

1. **Syntax Validation**: YAML/JSON structure is well-formed
2. **Schema Validation**: All required fields present, types correct
3. **Business Rules Validation**: Uniqueness constraints, context consistency
4. **Envoy Translation Validation**: Ensure configuration translates to valid Envoy resources

### Error Response Format

```go
// ValidationError represents a configuration validation failure
type ValidationError struct {
    Field   string `json:"field"`    // Field that failed validation
    Message string `json:"message"`  // Human-readable error message
}

// ErrorResponse is returned for failed API requests
type ErrorResponse struct {
    Status  string            `json:"status"`   // "error"
    Message string            `json:"message"`  // High-level error description
    Errors  []ValidationError `json:"errors"`   // Detailed validation errors
}
```

**Example Error Response**:
```json
{
  "status": "error",
  "message": "Configuration validation failed",
  "errors": [
    {
      "field": "data.context",
      "message": "Context must start with / and cannot end with /"
    },
    {
      "field": "data.operations[0].method",
      "message": "Invalid HTTP method: INVALID"
    }
  ]
}
```

---

## Concurrency & Consistency

### Thread Safety
- **In-Memory ConfigStore**: Protected by `sync.RWMutex` for concurrent access
  - Multiple readers can access simultaneously
  - Writers acquire exclusive lock
- **bbolt Transactions**: All read/write operations wrapped in bbolt transactions (ACID guarantees)
- **xDS Snapshot Updates**: go-control-plane cache is thread-safe; snapshot version increments are atomic

### Atomicity
Configuration create/update/delete operations maintain dual-write consistency:

```go
// Example: Atomic update to both in-memory and database
func (s *Service) CreateConfig(cfg *APIConfiguration) error {
    storedCfg := &StoredAPIConfig{
        ID:            generateID(),
        Configuration: *cfg,
        Status:        StatusPending,
        CreatedAt:     time.Now(),
        UpdatedAt:     time.Now(),
    }

    // Step 1: Write to database first (persistent storage)
    if err := s.db.SaveConfig(storedCfg); err != nil {
        return fmt.Errorf("database write failed: %w", err)
    }

    // Step 2: Update in-memory store (if this fails, we have inconsistency)
    if err := s.memStore.Add(storedCfg); err != nil {
        // Rollback: delete from database
        _ = s.db.DeleteConfig(storedCfg.ID)
        return fmt.Errorf("in-memory update failed: %w", err)
    }

    // Step 3: Generate and push xDS snapshot (non-blocking, async)
    go func() {
        snapshot, err := GenerateSnapshot(s.memStore)
        if err != nil {
            log.Error("Failed to generate snapshot", zap.Error(err))
            return
        }
        if err := s.xdsCache.SetSnapshot(context.Background(), "router-node", snapshot); err != nil {
            log.Error("Failed to update xDS cache", zap.Error(err))
        }
    }()

    return nil
}
```

**Atomicity Strategy**:
1. Write to database first (durable storage)
2. Update in-memory maps (fast access)
3. On in-memory failure: rollback database write
4. xDS snapshot generation happens asynchronously (doesn't block API response)

### Consistency Rules
1. **Uniqueness**: API name + version uniqueness enforced via in-memory index check + database constraint
2. **Context Consistency**: For same API name but different version, context must be identical (validated before insert/update)
3. **Snapshot Versioning**: Snapshot version monotonically increases (never decreases)
4. **Startup Consistency**: On startup, in-memory state is rebuilt from database (database is source of truth for recovery)

---

## Summary

This data model provides:
- **Clear contract** for user-facing API Configuration format
- **In-memory architecture** with `ConfigStore` for fast runtime access and xDS generation
- **Database persistence** using bbolt buckets for configurations, audit logs, and metadata
- **Startup recovery** by loading database contents into in-memory maps
- **SotW xDS protocol** implementation generating complete snapshots from in-memory state
- **Translation strategy** from in-memory configurations to Envoy xDS resources
- **Dual-write consistency** maintaining sync between database and in-memory maps
- **Validation rules** at multiple stages to ensure correctness
- **State management** for configuration lifecycle
- **Thread-safe operations** using RWMutex for concurrent access

**Key Architecture Decisions**:
1. In-memory maps are the primary data source for runtime operations and xDS generation
2. Database serves as persistence layer for durability and startup recovery
3. State-of-the-World (SotW) xDS protocol: every change generates a complete snapshot
4. Atomic updates to both database and in-memory maps with rollback on failure
5. Asynchronous xDS snapshot generation to avoid blocking API responses

---

## Code Generation Workflow

### Development Process

1. **Define API Contract**: Update OpenAPI specification in `gateway-controller/api/openapi.yaml`
   - Add/modify endpoints, request/response schemas, validation rules
   - OpenAPI spec is the single source of truth for the REST API

2. **Generate Code**: Run code generation
   ```bash
   cd gateway/gateway-controller
   make generate
   ```
   This runs: `oapi-codegen --config=oapi-codegen.yaml api/openapi.yaml`

3. **Review Generated Code**: Check `pkg/api/generated.go` for:
   - `ServerInterface` method signatures
   - Request/response type definitions
   - Route registration logic

4. **Implement Handlers**: Update `pkg/api/handlers/handlers.go` to satisfy `ServerInterface`
   - Implement business logic for each endpoint
   - Use generated types for type-safe request/response handling

5. **Build and Test**:
   ```bash
   make build        # Compiles the binary
   make test         # Runs unit and integration tests
   ```

### Version Control

- **Commit Generated Code**: The file `pkg/api/generated.go` should be committed to version control
  - Allows code review of generated changes
  - Ensures reproducible builds without requiring oapi-codegen at CI/CD time
  - Makes it clear when API contract changes (visible in diffs)

- **Pre-commit Check**: CI/CD pipeline should verify generated code is up-to-date:
  ```bash
  make generate
  git diff --exit-code pkg/api/generated.go  # Fails if generated code is stale
  ```

### Configuration File

The `gateway-controller/oapi-codegen.yaml` configuration:

```yaml
package: api
output: pkg/api/generated.go
generate:
  gin-server: true        # Generate Gin framework bindings
  models: true            # Generate request/response types
  embedded-spec: true     # Embed OpenAPI spec for runtime docs
  strict-server: false    # Use standard interface (not strict mode)
```

### Benefits of This Approach

1. **Contract-First Development**: API design drives implementation
2. **Type Safety**: Generated Go types match OpenAPI spec exactly
3. **Refactoring Safety**: Changes to OpenAPI spec trigger compile errors if handlers not updated
4. **Documentation Sync**: Generated code is always aligned with API documentation
5. **Reduced Boilerplate**: No manual request parsing, validation, or response serialization
6. **Testing**: Generated types make it easy to write type-safe integration tests

### Trade-offs

1. **Build Step Dependency**: Must run `make generate` before building after OpenAPI changes
2. **Generated Code Size**: Single-file generation can produce large files (acceptable for this project)
3. **Customization Limits**: Cannot manually edit generated code; must update OpenAPI spec instead
4. **Tool Dependency**: Requires oapi-codegen installation (handled by `go install` in Makefile)

---

**Status**: Data model complete with in-memory architecture, SotW protocol, and code generation workflow. Ready for implementation.
